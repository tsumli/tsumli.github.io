<!doctype html><html lang=en><head><title>CUDA: Cooperative Groupsについて · tsumli pages</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=description content='NVIDIAのblog を読んでいたのですが良く分からなかったのでコードを動かしながら見ていきます。

  Cooperative Groups とは?
  
    
    Link to heading
  


      Concepts of Cooperative Groups.
    


今までは__syncthreads()を使わないと同期できませんでした。しかし、これよりも小さなグループで同期を取りたいことがあります。Cooperative GroupsはCUDA 9から導入された機能で、これを使うことによって柔軟な同期が可能になります。
cooperative_groups.hをincludeするだけで使うことができます。そして、一般的にcgとaliasされることが多いようです。
#include <cooperative_groups.h>
namespace cg = cooperative_groups;
これより先のコードではこの定義を使うため注意してください。

  Thread Group
  
    
    Link to heading
  

Cooperative Groupsの中でも最も基本の型はthread_groupです。threadの数やthreadのindex ([0, size - 1]) は次のように取得できます。
__global__ void my_kernel() {
    cg::thread_block block = cg::this_thread_block();
    printf("size: %d, thread_rank: %d\n", block.size(), block.thread_rank());
}

int main() {
    my_kernel<<<2, 4>>>();
    THROW_IF_FAILED(cudaDeviceSynchronize());
    return 0;
}
出力は以下になります'><meta name=keywords content="cuda"><meta name=twitter:card content="summary"><meta name=twitter:title content="CUDA: Cooperative Groupsについて"><meta name=twitter:description content='NVIDIAのblog を読んでいたのですが良く分からなかったのでコードを動かしながら見ていきます。
Cooperative Groups とは? Link to heading Concepts of Cooperative Groups.
今までは__syncthreads()を使わないと同期できませんでした。しかし、これよりも小さなグループで同期を取りたいことがあります。Cooperative GroupsはCUDA 9から導入された機能で、これを使うことによって柔軟な同期が可能になります。
cooperative_groups.hをincludeするだけで使うことができます。そして、一般的にcgとaliasされることが多いようです。
#include <cooperative_groups.h> namespace cg = cooperative_groups; これより先のコードではこの定義を使うため注意してください。
Thread Group Link to heading Cooperative Groupsの中でも最も基本の型はthread_groupです。threadの数やthreadのindex ([0, size - 1]) は次のように取得できます。
__global__ void my_kernel() { cg::thread_block block = cg::this_thread_block(); printf("size: %d, thread_rank: %d\n", block.size(), block.thread_rank()); } int main() { my_kernel<<<2, 4>>>(); THROW_IF_FAILED(cudaDeviceSynchronize()); return 0; } 出力は以下になります'><meta property="og:url" content="https://tsumli.github.io/posts/cuda/cooperative-groups/"><meta property="og:site_name" content="tsumli pages"><meta property="og:title" content="CUDA: Cooperative Groupsについて"><meta property="og:description" content='NVIDIAのblog を読んでいたのですが良く分からなかったのでコードを動かしながら見ていきます。
Cooperative Groups とは? Link to heading Concepts of Cooperative Groups.
今までは__syncthreads()を使わないと同期できませんでした。しかし、これよりも小さなグループで同期を取りたいことがあります。Cooperative GroupsはCUDA 9から導入された機能で、これを使うことによって柔軟な同期が可能になります。
cooperative_groups.hをincludeするだけで使うことができます。そして、一般的にcgとaliasされることが多いようです。
#include <cooperative_groups.h> namespace cg = cooperative_groups; これより先のコードではこの定義を使うため注意してください。
Thread Group Link to heading Cooperative Groupsの中でも最も基本の型はthread_groupです。threadの数やthreadのindex ([0, size - 1]) は次のように取得できます。
__global__ void my_kernel() { cg::thread_block block = cg::this_thread_block(); printf("size: %d, thread_rank: %d\n", block.size(), block.thread_rank()); } int main() { my_kernel<<<2, 4>>>(); THROW_IF_FAILED(cudaDeviceSynchronize()); return 0; } 出力は以下になります'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-08-02T00:55:54+00:00"><meta property="article:modified_time" content="2024-08-02T00:55:54+00:00"><meta property="article:tag" content="Cuda"><link rel=canonical href=https://tsumli.github.io/posts/cuda/cooperative-groups/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.6445a802b9389c9660e1b07b724dcf5718b1065ed2d71b4eeaf981cc7cc5fc46.css integrity="sha256-ZEWoArk4nJZg4bB7ck3PVxixBl7S1xtO6vmBzHzF/EY=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/custom.min.9ae063529ba992021d731d7eb4542343b01d3632f7778e8467f94555b290cd32.css integrity="sha256-muBjUpupkgIdcx1+tFQjQ7AdNjL3d46EZ/lFVbKQzTI=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/img/favicon.svg sizes=any><link rel=icon type=image/png href=/img/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/img/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://tsumli.github.io/>tsumli pages
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://tsumli.github.io/posts/cuda/cooperative-groups/>CUDA: Cooperative Groupsについて</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2024-08-02T00:55:54Z>August 2, 2024
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
6-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/cuda/>Cuda</a></span></div></div></header><div class=post-content><p><a href=https://developer.nvidia.com/blog/cooperative-groups/ class=external-link target=_blank rel=noopener>NVIDIAのblog</a> を読んでいたのですが良く分からなかったのでコードを動かしながら見ていきます。</p><h2 id=cooperative-groups-とは>Cooperative Groups とは?
<a class=heading-link href=#cooperative-groups-%e3%81%a8%e3%81%af><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><figure><img src=images/overview.png alt="Concepts of Cooperative Groups."><figcaption><p>Concepts of Cooperative Groups.</p></figcaption></figure><p>今までは<code>__syncthreads()</code>を使わないと同期できませんでした。しかし、これよりも小さなグループで同期を取りたいことがあります。Cooperative GroupsはCUDA 9から導入された機能で、これを使うことによって柔軟な同期が可能になります。</p><p><code>cooperative_groups.h</code>をincludeするだけで使うことができます。そして、一般的に<code>cg</code>とaliasされることが多いようです。</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>#include</span> <span style=color:#8b949e;font-weight:700;font-style:italic>&lt;cooperative_groups.h&gt;</span><span style=color:#8b949e;font-weight:700;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic></span><span style=color:#ff7b72>namespace</span> cg <span style=color:#ff7b72;font-weight:700>=</span> cooperative_groups;
</span></span></code></pre></div><p>これより先のコードではこの定義を使うため注意してください。</p><h2 id=thread-group>Thread Group
<a class=heading-link href=#thread-group><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Cooperative Groupsの中でも最も基本の型は<code>thread_group</code>です。threadの数やthreadのindex ([0, size - 1]) は次のように取得できます。</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>__global__ <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>my_kernel</span>() {
</span></span><span style=display:flex><span>    cg<span style=color:#ff7b72;font-weight:700>::</span>thread_block block <span style=color:#ff7b72;font-weight:700>=</span> cg<span style=color:#ff7b72;font-weight:700>::</span>this_thread_block();
</span></span><span style=display:flex><span>    printf(<span style=color:#a5d6ff>&#34;size: %d, thread_rank: %d</span><span style=color:#79c0ff>\n</span><span style=color:#a5d6ff>&#34;</span>, block.size(), block.thread_rank());
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>int</span> <span style=color:#d2a8ff;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>    my_kernel<span style=color:#ff7b72;font-weight:700>&lt;&lt;&lt;</span><span style=color:#a5d6ff>2</span>, <span style=color:#a5d6ff>4</span><span style=color:#ff7b72;font-weight:700>&gt;&gt;&gt;</span>();
</span></span><span style=display:flex><span>    THROW_IF_FAILED(cudaDeviceSynchronize());
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> <span style=color:#a5d6ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>出力は以下になります</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>size: 4, thread_rank: 0
</span></span><span style=display:flex><span>size: 4, thread_rank: 1
</span></span><span style=display:flex><span>size: 4, thread_rank: 2
</span></span><span style=display:flex><span>size: 4, thread_rank: 3
</span></span><span style=display:flex><span>size: 4, thread_rank: 0
</span></span><span style=display:flex><span>size: 4, thread_rank: 1
</span></span><span style=display:flex><span>size: 4, thread_rank: 2
</span></span><span style=display:flex><span>size: 4, thread_rank: 3
</span></span></code></pre></div><h2 id=thread-group-collective-operations>Thread Group Collective Operations
<a class=heading-link href=#thread-group-collective-operations><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Collective operationsは同期が必要だったり、特定のthreadとのコミュニケーションが必要な操作のことを指します。最も簡単な操作はグループ全体の同期です。これは<code>sync()</code>を使うことで可能になります。</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>g.sync();
</span></span><span style=display:flex><span>cg<span style=color:#ff7b72;font-weight:700>::</span>synchronize(g);
</span></span></code></pre></div><h2 id=thread-blocks>Thread Blocks
<a class=heading-link href=#thread-blocks><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p><code>thread_block</code>はkernelの中で thread block (= CUDA並列プログラミングにおける基本的な単位) を表す新しい型です。次のように初期化されます。</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>cg<span style=color:#ff7b72;font-weight:700>::</span>thread_block block <span style=color:#ff7b72;font-weight:700>=</span> cg<span style=color:#ff7b72;font-weight:700>::</span>this_thread_block();
</span></span></code></pre></div><p>この<code>thread_block</code>グループの同期は<code>__syncthreads()</code>と同じになります。つまり、以下の5つは同じ操作になります。</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>__syncthreads();
</span></span><span style=display:flex><span>block.sync();
</span></span><span style=display:flex><span>cg<span style=color:#ff7b72;font-weight:700>::</span>synchronize(block);
</span></span><span style=display:flex><span>cg<span style=color:#ff7b72;font-weight:700>::</span>this_thread_block().sync();
</span></span><span style=display:flex><span>cg<span style=color:#ff7b72;font-weight:700>::</span>synchronize(this_thread_block());
</span></span></code></pre></div><p><code>thread_block</code>は<code>thread_group</code>のインターフェースに加えblock特有の関数が追加されています。</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>dim3 <span style=color:#d2a8ff;font-weight:700>group_index</span>();  <span style=color:#8b949e;font-style:italic>// 3-dimensional block index within the grid
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>dim3 <span style=color:#d2a8ff;font-weight:700>thread_index</span>(); <span style=color:#8b949e;font-style:italic>// 3-dimensional thread index within the block
</span></span></span></code></pre></div><p>これはそれぞれCUDAでいうところの<code>blockIdx</code>と<code>threadIdx</code>です。</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>__global__ <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>my_kernel</span>() {
</span></span><span style=display:flex><span>    cg<span style=color:#ff7b72;font-weight:700>::</span>thread_block block <span style=color:#ff7b72;font-weight:700>=</span> cg<span style=color:#ff7b72;font-weight:700>::</span>this_thread_block();
</span></span><span style=display:flex><span>    printf(<span style=color:#a5d6ff>&#34;group_index: (%d, %d, %d), thread_index: (%d, %d, %d)</span><span style=color:#79c0ff>\n</span><span style=color:#a5d6ff>&#34;</span>, block.group_index().x,
</span></span><span style=display:flex><span>           block.group_index().y, block.group_index().z, block.thread_index().x,
</span></span><span style=display:flex><span>           block.thread_index().y, block.thread_index().z);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>int</span> <span style=color:#d2a8ff;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>    my_kernel<span style=color:#ff7b72;font-weight:700>&lt;&lt;&lt;</span><span style=color:#a5d6ff>2</span>, <span style=color:#a5d6ff>4</span><span style=color:#ff7b72;font-weight:700>&gt;&gt;&gt;</span>();
</span></span><span style=display:flex><span>    THROW_IF_FAILED(cudaDeviceSynchronize());
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> <span style=color:#a5d6ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>出力は次の通りです</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-md data-lang=md><span style=display:flex><span>group_index: (1, 0, 0), thread_index: (0, 0, 0)
</span></span><span style=display:flex><span>group_index: (1, 0, 0), thread_index: (1, 0, 0)
</span></span><span style=display:flex><span>group_index: (1, 0, 0), thread_index: (2, 0, 0)
</span></span><span style=display:flex><span>group_index: (1, 0, 0), thread_index: (3, 0, 0)
</span></span><span style=display:flex><span>group_index: (0, 0, 0), thread_index: (0, 0, 0)
</span></span><span style=display:flex><span>group_index: (0, 0, 0), thread_index: (1, 0, 0)
</span></span><span style=display:flex><span>group_index: (0, 0, 0), thread_index: (2, 0, 0)
</span></span><span style=display:flex><span>group_index: (0, 0, 0), thread_index: (3, 0, 0)
</span></span></code></pre></div><p>(疑問) <code>blockIdx</code>/<code>threadIdx</code>と<code>group_index</code>/<code>thread_idx</code>はどう使い分けるべき?</p><h2 id=partitioning-groups>Partitioning Groups
<a class=heading-link href=#partitioning-groups><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>ここからがCooperative Groupsの本領発揮といったところでしょうか。groupを分割する機能についてみていきます。<code>cg::tiled_partition()</code>でblockを複数の"tile"に分割することができます。以下の例は、thread blockを32個のthreadを持つtileに分割する例です。</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>cg<span style=color:#ff7b72;font-weight:700>::</span>thread_group tile32 <span style=color:#ff7b72;font-weight:700>=</span> cg<span style=color:#ff7b72;font-weight:700>::</span>tiled_partition(cg<span style=color:#ff7b72;font-weight:700>::</span>this_thread_block(), <span style=color:#a5d6ff>32</span>);
</span></span></code></pre></div><p>それぞれのthreadが32-threadのグループへのhandleを得ます。さらに4-threadのtileに分割してみましょう</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>cg<span style=color:#ff7b72;font-weight:700>::</span>thread_group tile4 <span style=color:#ff7b72;font-weight:700>=</span> cg<span style=color:#ff7b72;font-weight:700>::</span>tiled_partition(tile32, <span style=color:#a5d6ff>4</span>);
</span></span></code></pre></div><p><code>tiled_partition()</code>によって作成されたthread groupも他のthread group同様の振る舞いをします。ここで、次の例を見てみましょう。</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>__global__ <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>my_kernel</span>() {
</span></span><span style=display:flex><span>    cg<span style=color:#ff7b72;font-weight:700>::</span>thread_block block <span style=color:#ff7b72;font-weight:700>=</span> cg<span style=color:#ff7b72;font-weight:700>::</span>this_thread_block();
</span></span><span style=display:flex><span>    cg<span style=color:#ff7b72;font-weight:700>::</span>thread_group tile4 <span style=color:#ff7b72;font-weight:700>=</span> cg<span style=color:#ff7b72;font-weight:700>::</span>tiled_partition(block, <span style=color:#a5d6ff>4</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (tile4.thread_rank() <span style=color:#ff7b72;font-weight:700>==</span> <span style=color:#a5d6ff>0</span>) {
</span></span><span style=display:flex><span>        printf(<span style=color:#a5d6ff>&#34;Hello from tile4 rank 0: %d</span><span style=color:#79c0ff>\n</span><span style=color:#a5d6ff>&#34;</span>, block.thread_rank());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>int</span> <span style=color:#d2a8ff;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>    my_kernel<span style=color:#ff7b72;font-weight:700>&lt;&lt;&lt;</span><span style=color:#a5d6ff>2</span>, dim3{<span style=color:#a5d6ff>2</span>, <span style=color:#a5d6ff>16</span>, <span style=color:#a5d6ff>1</span>}<span style=color:#ff7b72;font-weight:700>&gt;&gt;&gt;</span>();
</span></span><span style=display:flex><span>    THROW_IF_FAILED(cudaDeviceSynchronize());
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> <span style=color:#a5d6ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>出力は次の通り</p><pre tabindex=0><code>Hello from tile4 rank 0: 0
Hello from tile4 rank 0: 4
Hello from tile4 rank 0: 8
Hello from tile4 rank 0: 12
Hello from tile4 rank 0: 16
Hello from tile4 rank 0: 20
Hello from tile4 rank 0: 24
Hello from tile4 rank 0: 28
Hello from tile4 rank 0: 0
Hello from tile4 rank 0: 4
Hello from tile4 rank 0: 8
Hello from tile4 rank 0: 12
Hello from tile4 rank 0: 16
Hello from tile4 rank 0: 20
Hello from tile4 rank 0: 24
Hello from tile4 rank 0: 28
</code></pre><p>tile4は4つのthreadごとに<code>thread_rank()</code>が0になることがわかります</p><h2 id=modularity>Modularity
<a class=heading-link href=#modularity><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>さまざまなthread groupのサイズに対して一貫したインターフェースを利用できるため、race conditionやdeadlockを防ぐことができます。</p><p>例えば、次のようなコードではdeadlockが発生します。</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>__device__ <span style=color:#ff7b72>int</span> <span style=color:#d2a8ff;font-weight:700>sum</span>(<span style=color:#ff7b72>int</span> <span style=color:#ff7b72;font-weight:700>*</span>x, <span style=color:#ff7b72>int</span> n) 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    __syncthreads();
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> total;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>__global__ <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>parallel_kernel</span>(<span style=color:#ff7b72>float</span> <span style=color:#ff7b72;font-weight:700>*</span>x, <span style=color:#ff7b72>int</span> n)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (threadIdx.x <span style=color:#ff7b72;font-weight:700>&lt;</span> blockDim.x <span style=color:#ff7b72;font-weight:700>/</span> <span style=color:#a5d6ff>2</span>) {
</span></span><span style=display:flex><span>        sum(x, count);  <span style=color:#8b949e;font-style:italic>// error: half of threads in block skip
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>                        <span style=color:#8b949e;font-style:italic>// __syncthreads() =&gt; deadlock
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>しかし、<code>thread_block</code>を引数に取ることでこのようなdeadlockを防ぐことができます。</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Now much clearer that a whole thread block is expected to call
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>__device__ <span style=color:#ff7b72>int</span> <span style=color:#d2a8ff;font-weight:700>sum</span>(cg<span style=color:#ff7b72;font-weight:700>::</span>thread_block block, <span style=color:#ff7b72>int</span> <span style=color:#ff7b72;font-weight:700>*</span>x, <span style=color:#ff7b72>int</span> n) 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    block.sync();
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> total;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>__global__ <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>parallel_kernel</span>(<span style=color:#ff7b72>float</span> <span style=color:#ff7b72;font-weight:700>*</span>x, <span style=color:#ff7b72>int</span> n)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    sum(cg<span style=color:#ff7b72;font-weight:700>::</span>this_thread_block(), x, count); <span style=color:#8b949e;font-style:italic>// no divergence around call
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>}
</span></span></code></pre></div><p>以下は32 threadのtileを使用したsum関数の例です。tileごとに合計を計算し、最終的に<code>atomicAdd</code>で足し合わされます。</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>__global__ <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>sum_kernel_32</span>(<span style=color:#ff7b72>int</span> <span style=color:#ff7b72;font-weight:700>*</span>sum, <span style=color:#ff7b72>int</span> <span style=color:#ff7b72;font-weight:700>*</span>input, <span style=color:#ff7b72>int</span> n)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span> my_sum <span style=color:#ff7b72;font-weight:700>=</span> thread_sum(input, n); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>extern</span> __shared__ <span style=color:#ff7b72>int</span> temp[];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>auto</span> g <span style=color:#ff7b72;font-weight:700>=</span> cg<span style=color:#ff7b72;font-weight:700>::</span>this_thread_block();
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>auto</span> tileIdx <span style=color:#ff7b72;font-weight:700>=</span> g.thread_rank() <span style=color:#ff7b72;font-weight:700>/</span> <span style=color:#a5d6ff>32</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span><span style=color:#ff7b72;font-weight:700>*</span> t <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72;font-weight:700>&amp;</span>temp[<span style=color:#a5d6ff>32</span> <span style=color:#ff7b72;font-weight:700>*</span> tileIdx];
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>auto</span> tile32 <span style=color:#ff7b72;font-weight:700>=</span> cg<span style=color:#ff7b72;font-weight:700>::</span>tiled_partition(g, <span style=color:#a5d6ff>32</span>);  
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span> tile_sum <span style=color:#ff7b72;font-weight:700>=</span> reduce_sum(tile32, t, my_sum);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (tile32.thread_rank() <span style=color:#ff7b72;font-weight:700>==</span> <span style=color:#a5d6ff>0</span>) {
</span></span><span style=display:flex><span>        atomicAdd(sum, tile_sum);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>(疑問) 上の方法だと1つのthreadごとに<code>atomicAdd</code>するよりも速くなる?</p><h2 id=optimizing-for-the-gpu-warp-size>Optimizing for the GPU Warp Size
<a class=heading-link href=#optimizing-for-the-gpu-warp-size><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p><code>cg::tiled_partition()</code>はtemplate parameterをとるバージョンもあります</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>cg<span style=color:#ff7b72;font-weight:700>::</span>thread_block_tile<span style=color:#ff7b72;font-weight:700>&lt;</span><span style=color:#a5d6ff>32</span><span style=color:#ff7b72;font-weight:700>&gt;</span> tile32 <span style=color:#ff7b72;font-weight:700>=</span> cg<span style=color:#ff7b72;font-weight:700>::</span>tiled_partition<span style=color:#ff7b72;font-weight:700>&lt;</span><span style=color:#a5d6ff>32</span><span style=color:#ff7b72;font-weight:700>&gt;</span>(this_thread_block());
</span></span><span style=display:flex><span>cg<span style=color:#ff7b72;font-weight:700>::</span>thread_block_tile<span style=color:#ff7b72;font-weight:700>&lt;</span><span style=color:#a5d6ff>4</span><span style=color:#ff7b72;font-weight:700>&gt;</span>  tile4  <span style=color:#ff7b72;font-weight:700>=</span> cg<span style=color:#ff7b72;font-weight:700>::</span>tiled_partition<span style=color:#ff7b72;font-weight:700>&lt;</span><span style=color:#a5d6ff>4</span><span style=color:#ff7b72;font-weight:700>&gt;</span> (this_thread_block());
</span></span></code></pre></div><p>これを使用することでreductionのコードを少し最適化することができます。</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#ff7b72>template</span> <span style=color:#ff7b72;font-weight:700>&lt;</span><span style=color:#ff7b72>typename</span> group_t<span style=color:#ff7b72;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>__device__ <span style=color:#ff7b72>int</span> reduce_sum(group_t g, <span style=color:#ff7b72>int</span> <span style=color:#ff7b72;font-weight:700>*</span>temp, <span style=color:#ff7b72>int</span> val)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span> lane <span style=color:#ff7b72;font-weight:700>=</span> g.thread_rank();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Each iteration halves the number of active threads
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    <span style=color:#8b949e;font-style:italic>// Each thread adds its partial sum[i] to sum[lane+i]
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    <span style=color:#8b949e;font-weight:700;font-style:italic>#pragma unroll
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic></span>    <span style=color:#ff7b72>for</span> (<span style=color:#ff7b72>int</span> i <span style=color:#ff7b72;font-weight:700>=</span> g.size() <span style=color:#ff7b72;font-weight:700>/</span> <span style=color:#a5d6ff>2</span>; i <span style=color:#ff7b72;font-weight:700>&gt;</span> <span style=color:#a5d6ff>0</span>; i <span style=color:#ff7b72;font-weight:700>/=</span> <span style=color:#a5d6ff>2</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        temp[lane] <span style=color:#ff7b72;font-weight:700>=</span> val;
</span></span><span style=display:flex><span>        g.sync(); <span style=color:#8b949e;font-style:italic>// wait for all threads to store
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>        <span style=color:#ff7b72>if</span> (lane <span style=color:#ff7b72;font-weight:700>&lt;</span> i) val <span style=color:#ff7b72;font-weight:700>+=</span> temp[lane <span style=color:#ff7b72;font-weight:700>+</span> i];
</span></span><span style=display:flex><span>        g.sync(); <span style=color:#8b949e;font-style:italic>// wait for all threads to load
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> val; <span style=color:#8b949e;font-style:italic>// note: only thread 0 will return full sum
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>}
</span></span></code></pre></div><p>また、tileのサイズがwarpのサイズと一致した時、compilerは同期を省略できる場合があります。熟練のプログラマがwarpを考慮した上で同期を取り除くことがよく行われるが、thread groupを明示的に同期するようなコードを書くことでrace conditionの発生を防ぐことができます (compilerが最適化してくれる?) 。</p><h2 id=warp-level-collectives>Warp-Level Collectives
<a class=heading-link href=#warp-level-collectives><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>thread block tilesは次のwarp-levelなcollective functionをもつ。</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>.shfl()
</span></span><span style=display:flex><span>.shfl_down()
</span></span><span style=display:flex><span>.shfl_up()
</span></span><span style=display:flex><span>.shfl_xor()
</span></span><span style=display:flex><span>.any()
</span></span><span style=display:flex><span>.all()
</span></span><span style=display:flex><span>.ballot()
</span></span><span style=display:flex><span>.match_any()
</span></span><span style=display:flex><span>.match_all()
</span></span></code></pre></div><p>ここで、<code>shfl_down()</code>を使用したreductionのコードをみてみましょう。このコードではshared memoryを使用していません。</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>__device__ <span style=color:#ff7b72>int</span> <span style=color:#d2a8ff;font-weight:700>thread_sum</span>(<span style=color:#ff7b72>int</span> <span style=color:#ff7b72;font-weight:700>*</span>input, <span style=color:#ff7b72>int</span> n) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span> sum <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>for</span> (<span style=color:#ff7b72>int</span> i <span style=color:#ff7b72;font-weight:700>=</span> blockIdx.x <span style=color:#ff7b72;font-weight:700>*</span> blockDim.x <span style=color:#ff7b72;font-weight:700>+</span> threadIdx.x; i <span style=color:#ff7b72;font-weight:700>&lt;</span> n <span style=color:#ff7b72;font-weight:700>/</span> <span style=color:#a5d6ff>4</span>; i <span style=color:#ff7b72;font-weight:700>+=</span> blockDim.x <span style=color:#ff7b72;font-weight:700>*</span> gridDim.x) {
</span></span><span style=display:flex><span>        int4 in <span style=color:#ff7b72;font-weight:700>=</span> ((int4 <span style=color:#ff7b72;font-weight:700>*</span>)input)[i];
</span></span><span style=display:flex><span>        sum <span style=color:#ff7b72;font-weight:700>+=</span> in.x <span style=color:#ff7b72;font-weight:700>+</span> in.y <span style=color:#ff7b72;font-weight:700>+</span> in.z <span style=color:#ff7b72;font-weight:700>+</span> in.w;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> sum;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>template</span> <span style=color:#ff7b72;font-weight:700>&lt;</span><span style=color:#ff7b72>int</span> tile_sz<span style=color:#ff7b72;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>__device__ <span style=color:#ff7b72>int</span> reduce_sum_tile_shfl(cg<span style=color:#ff7b72;font-weight:700>::</span>thread_block_tile<span style=color:#ff7b72;font-weight:700>&lt;</span>tile_sz<span style=color:#ff7b72;font-weight:700>&gt;</span> g, <span style=color:#ff7b72>int</span> val) {
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Each iteration halves the number of active threads
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    <span style=color:#8b949e;font-style:italic>// Each thread adds its partial sum[i] to sum[lane+i]
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    <span style=color:#ff7b72>for</span> (<span style=color:#ff7b72>int</span> i <span style=color:#ff7b72;font-weight:700>=</span> g.size() <span style=color:#ff7b72;font-weight:700>/</span> <span style=color:#a5d6ff>2</span>; i <span style=color:#ff7b72;font-weight:700>&gt;</span> <span style=color:#a5d6ff>0</span>; i <span style=color:#ff7b72;font-weight:700>/=</span> <span style=color:#a5d6ff>2</span>) {
</span></span><span style=display:flex><span>        val <span style=color:#ff7b72;font-weight:700>+=</span> g.shfl_down(val, i);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> val;  <span style=color:#8b949e;font-style:italic>// note: only thread 0 will return full sum
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>template</span> <span style=color:#ff7b72;font-weight:700>&lt;</span><span style=color:#ff7b72>int</span> tile_sz<span style=color:#ff7b72;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>__global__ <span style=color:#ff7b72>void</span> sum_kernel_tile_shfl(<span style=color:#ff7b72>int</span> <span style=color:#ff7b72;font-weight:700>*</span>sum, <span style=color:#ff7b72>int</span> <span style=color:#ff7b72;font-weight:700>*</span>input, <span style=color:#ff7b72>int</span> n) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span> my_sum <span style=color:#ff7b72;font-weight:700>=</span> thread_sum(input, n);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>auto</span> tile <span style=color:#ff7b72;font-weight:700>=</span> cg<span style=color:#ff7b72;font-weight:700>::</span>tiled_partition<span style=color:#ff7b72;font-weight:700>&lt;</span>tile_sz<span style=color:#ff7b72;font-weight:700>&gt;</span>(cg<span style=color:#ff7b72;font-weight:700>::</span>this_thread_block());
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span> tile_sum <span style=color:#ff7b72;font-weight:700>=</span> reduce_sum_tile_shfl<span style=color:#ff7b72;font-weight:700>&lt;</span>tile_sz<span style=color:#ff7b72;font-weight:700>&gt;</span>(tile, my_sum);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (tile.thread_rank() <span style=color:#ff7b72;font-weight:700>==</span> <span style=color:#a5d6ff>0</span>) {
</span></span><span style=display:flex><span>        atomicAdd(sum, tile_sum);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=discovering-thread-concurrency>Discovering Thread Concurrency
<a class=heading-link href=#discovering-thread-concurrency><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>GPUでは32個のthreadからなるwarp単位でthread命令を実行します。コード内の条件分岐によってwarp内のthreadが分岐すると、アクティブなthreadとそうでないthreadに分かれます。アクティブなままでいるthreadは<code>coalesced</code>と呼ばれます。Cooperative Groupsではこのようなthreadのgroupを取得するための関数を提供しています。</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>cg<span style=color:#ff7b72;font-weight:700>::</span>coalesced_group active <span style=color:#ff7b72;font-weight:700>=</span> cg<span style=color:#ff7b72;font-weight:700>::</span>coalesced_threads();
</span></span></code></pre></div><p>例えば、次のような奇数のthread rankをもつthreadのみで計算を行う場合、アクティブなthreadのみに対して同期を実行できる。しかし、coalesced threadはwarpを跨ぐことはないため注意が必要である。</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#ff7b72>auto</span> block <span style=color:#ff7b72;font-weight:700>=</span> cg<span style=color:#ff7b72;font-weight:700>::</span>this_thread_block();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>if</span> (block.thread_rank() <span style=color:#ff7b72;font-weight:700>%</span> <span style=color:#a5d6ff>2</span>) {
</span></span><span style=display:flex><span>    cg<span style=color:#ff7b72;font-weight:700>::</span>coalesced_group active <span style=color:#ff7b72;font-weight:700>=</span> cg<span style=color:#ff7b72;font-weight:700>::</span>coalesced_threads();
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    active.sync();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>良い例として"warp-aggregation atomics"を考えてみましょう。warp-aggregationではwarpのthreadが増加分を合計したあと、その中の1つのthreadがグローバル変数のカウンタにアトミックに加算を行います。これによってatomic演算がwarpのサイズ分だけ減り、パフォーマンスがよくなります。</p><p>しかし、ここでキーポイントとなるのは、warpの最初のthreadでアトミック演算を行おうとしても、それがアクティブなthreadでない可能性があるということです。ここで、<code>coalesced_group</code>の<code>thread_rank()</code>を使うことができます。</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>__device__ <span style=color:#ff7b72>int</span> <span style=color:#d2a8ff;font-weight:700>atomicAggInc</span>(<span style=color:#ff7b72>int</span> <span style=color:#ff7b72;font-weight:700>*</span>ptr) {
</span></span><span style=display:flex><span>    cg<span style=color:#ff7b72;font-weight:700>::</span>coalesced_group g <span style=color:#ff7b72;font-weight:700>=</span> cg<span style=color:#ff7b72;font-weight:700>::</span>coalesced_threads();
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span> prev;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// elect the first active thread to perform atomic add
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    <span style=color:#ff7b72>if</span> (g.thread_rank() <span style=color:#ff7b72;font-weight:700>==</span> <span style=color:#a5d6ff>0</span>) {
</span></span><span style=display:flex><span>        prev <span style=color:#ff7b72;font-weight:700>=</span> atomicAdd(ptr, g.size());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// broadcast previous value within the warp
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    <span style=color:#8b949e;font-style:italic>// and add each active thread’s rank to it
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    prev <span style=color:#ff7b72;font-weight:700>=</span> g.thread_rank() <span style=color:#ff7b72;font-weight:700>+</span> g.shfl(prev, <span style=color:#a5d6ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> prev;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=実験>実験
<a class=heading-link href=#%e5%ae%9f%e9%a8%93><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>さて、ここまでブログの記事をざっくりとみていきましたが、実際にコードを動かしてみましょう (今までもいくつか動かしていましたが&mldr;)
<code>cg::thread_block</code>から取得できる情報をみていきます。一気に出力すると良く分からなくなるのでコメントアウトしながら動かします。</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>__global__ <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>my_kernel</span>() {
</span></span><span style=display:flex><span>    cg<span style=color:#ff7b72;font-weight:700>::</span>thread_block block <span style=color:#ff7b72;font-weight:700>=</span> cg<span style=color:#ff7b72;font-weight:700>::</span>this_thread_block();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    dim3 dim_threads <span style=color:#ff7b72;font-weight:700>=</span> block.dim_threads();
</span></span><span style=display:flex><span>    uint num_threads <span style=color:#ff7b72;font-weight:700>=</span> block.num_threads();
</span></span><span style=display:flex><span>    uint get_type <span style=color:#ff7b72;font-weight:700>=</span> block.get_type();
</span></span><span style=display:flex><span>    dim3 group_dim <span style=color:#ff7b72;font-weight:700>=</span> block.group_dim();
</span></span><span style=display:flex><span>    dim3 group_index <span style=color:#ff7b72;font-weight:700>=</span> block.group_index();
</span></span><span style=display:flex><span>    uint thread_rank <span style=color:#ff7b72;font-weight:700>=</span> block.thread_rank();
</span></span><span style=display:flex><span>    uint size <span style=color:#ff7b72;font-weight:700>=</span> block.size();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    printf(<span style=color:#a5d6ff>&#34;dim_threads: (%d, %d, %d)</span><span style=color:#79c0ff>\n</span><span style=color:#a5d6ff>&#34;</span>, dim_threads.x, dim_threads.y, dim_threads.z);
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// printf(&#34;num_threads: %d\n&#34;, num_threads);
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    <span style=color:#8b949e;font-style:italic>// printf(&#34;get_type: %d\n&#34;, get_type);
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    <span style=color:#8b949e;font-style:italic>// printf(&#34;group_dim: (%d, %d, %d)\n&#34;, group_dim.x, group_dim.y, group_dim.z);
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    <span style=color:#8b949e;font-style:italic>// printf(&#34;group_index: (%d, %d, %d)\n&#34;, group_index.x, group_index.y, group_index.z);
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    <span style=color:#8b949e;font-style:italic>// printf(&#34;thread_index: (%d, %d, %d)\n&#34;, thread_index.x, thread_index.y, thread_index.z);
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    <span style=color:#8b949e;font-style:italic>// printf(&#34;thread_rank: %d\n&#34;, thread_rank);
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    <span style=color:#8b949e;font-style:italic>// printf(&#34;size: %d\n&#34;, size);
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>int</span> <span style=color:#d2a8ff;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>    my_kernel<span style=color:#ff7b72;font-weight:700>&lt;&lt;&lt;</span>dim3{<span style=color:#a5d6ff>2</span>, <span style=color:#a5d6ff>3</span>, <span style=color:#a5d6ff>4</span>}, dim3{<span style=color:#a5d6ff>5</span>, <span style=color:#a5d6ff>6</span>, <span style=color:#a5d6ff>7</span>}<span style=color:#ff7b72;font-weight:700>&gt;&gt;&gt;</span>();
</span></span><span style=display:flex><span>    THROW_IF_FAILED(cudaDeviceSynchronize());
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> <span style=color:#a5d6ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=dim_threads>dim_threads
<a class=heading-link href=#dim_threads><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>dim_threads: <span style=color:#ff7b72;font-weight:700>(</span>5, 6, 7<span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>dim_threads: <span style=color:#ff7b72;font-weight:700>(</span>5, 6, 7<span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>dim_threads: <span style=color:#ff7b72;font-weight:700>(</span>5, 6, 7<span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p><code>dim3{5, 6, 7}</code>を返していますね</p><h3 id=num_threads>num_threads
<a class=heading-link href=#num_threads><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>num_threads: <span style=color:#a5d6ff>210</span>
</span></span><span style=display:flex><span>num_threads: <span style=color:#a5d6ff>210</span>
</span></span><span style=display:flex><span>num_threads: <span style=color:#a5d6ff>210</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>$5 \times 6 \times 7 = 210$個のthreadが実行されています</p><h3 id=get_type>get_type
<a class=heading-link href=#get_type><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>get_type: <span style=color:#a5d6ff>4</span>
</span></span><span style=display:flex><span>get_type: <span style=color:#a5d6ff>4</span>
</span></span><span style=display:flex><span>get_type: <span style=color:#a5d6ff>4</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>このtypeは以下の値に該当するようです。つまり、このblockのtypeは<code>thread_block_id</code>であることがわかります。</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// cooperative_group.h
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span><span style=color:#ff7b72>namespace</span> details {
</span></span><span style=display:flex><span>    _CG_CONST_DECL <span style=color:#ff7b72>unsigned</span> <span style=color:#ff7b72>int</span> coalesced_group_id <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>1</span>;
</span></span><span style=display:flex><span>    _CG_CONST_DECL <span style=color:#ff7b72>unsigned</span> <span style=color:#ff7b72>int</span> multi_grid_group_id <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>2</span>;
</span></span><span style=display:flex><span>    _CG_CONST_DECL <span style=color:#ff7b72>unsigned</span> <span style=color:#ff7b72>int</span> grid_group_id <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>3</span>;
</span></span><span style=display:flex><span>    _CG_CONST_DECL <span style=color:#ff7b72>unsigned</span> <span style=color:#ff7b72>int</span> thread_block_id <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>4</span>;
</span></span><span style=display:flex><span>    _CG_CONST_DECL <span style=color:#ff7b72>unsigned</span> <span style=color:#ff7b72>int</span> multi_tile_group_id <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>5</span>;
</span></span><span style=display:flex><span>    _CG_CONST_DECL <span style=color:#ff7b72>unsigned</span> <span style=color:#ff7b72>int</span> cluster_group_id <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>6</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=group_dim>group_dim
<a class=heading-link href=#group_dim><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>group_dim: <span style=color:#ff7b72;font-weight:700>(</span>5, 6, 7<span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>group_dim: <span style=color:#ff7b72;font-weight:700>(</span>5, 6, 7<span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>group_dim: <span style=color:#ff7b72;font-weight:700>(</span>5, 6, 7<span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>これも<code>dim3{5, 6, 7}</code>を返しています。</p><h3 id=group_index-thread_index>group_index, thread_index
<a class=heading-link href=#group_index-thread_index><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>...
</span></span><span style=display:flex><span>group_index: <span style=color:#ff7b72;font-weight:700>(</span>0, 0, 1<span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>group_index: <span style=color:#ff7b72;font-weight:700>(</span>0, 0, 1<span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>group_index: <span style=color:#ff7b72;font-weight:700>(</span>0, 0, 0<span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>...
</span></span><span style=display:flex><span>thread_index: <span style=color:#ff7b72;font-weight:700>(</span>4, 3, 0<span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>thread_index: <span style=color:#ff7b72;font-weight:700>(</span>0, 4, 0<span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>thread_index: <span style=color:#ff7b72;font-weight:700>(</span>1, 4, 0<span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>こちらについては先ほど紹介した通り<code>blockIdx</code>/<code>threadIdx</code>と同じですね</p><h3 id=size>size
<a class=heading-link href=#size><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>...
</span></span><span style=display:flex><span>size: <span style=color:#a5d6ff>210</span>
</span></span><span style=display:flex><span>size: <span style=color:#a5d6ff>210</span>
</span></span><span style=display:flex><span>size: <span style=color:#a5d6ff>210</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>これは$5 \times 6 \times 7$と一致します。</p><h3 id=thread_rank>thread_rank
<a class=heading-link href=#thread_rank><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>...
</span></span><span style=display:flex><span>thread_rank: <span style=color:#a5d6ff>189</span>
</span></span><span style=display:flex><span>thread_rank: <span style=color:#a5d6ff>190</span>
</span></span><span style=display:flex><span>thread_rank: <span style=color:#a5d6ff>191</span>
</span></span><span style=display:flex><span>thread_rank: <span style=color:#a5d6ff>64</span>
</span></span><span style=display:flex><span>thread_rank: <span style=color:#a5d6ff>65</span>
</span></span><span style=display:flex><span>thread_rank: <span style=color:#a5d6ff>66</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>この値は0から209まで取るかと思ったのですが、調べてみると0から191までのようです。6つ分のwarpのみ動いているということでしょうか。ここで気がついたのですが、標準出力の行数も4608 ($= 2 * 3 * 4 * 192$) となっていました。192から209番目のthreadは実行されていないのは、今回のコードがただprintfするコードのためcompilerによる最適化がかかったと考えられます。</p><p>続きは余力があれば&mldr;</p></div><footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//tsumli.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}(),document.addEventListener("themeChanged",function(){document.readyState=="complete"&&DISQUS.reset({reload:!0,config:disqus_config})})</script></footer></article><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})'></script></section></div><footer class=footer><section class=container>©
2019 -
2025
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>