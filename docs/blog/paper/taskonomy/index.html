<!doctype html><html lang=ja>
<head>
<title>Taskonomyを読む | tsumli-pages</title>
<meta charset=utf-8>
<meta name=language content="en">
<meta name=description content>
<meta name=keywords content="転移学習 ,Taskonomy ,transfer-learning">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<link rel="shortcut icon" type=image/png href=https://tsumli.github.io/favicon.ico>
<link type=text/css rel=stylesheet href=https://tsumli.github.io/css/post.min.86d1effd4c412b85ac13db53a90c473a0f256f789b821e131125c9aa25cb6a6d.css integrity="sha256-htHv/UxBK4WsE9tTqQxHOg8lb3ibgh4TESXJqiXLam0=">
<link type=text/css rel=stylesheet href=https://tsumli.github.io/css/custom.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css integrity="sha256-47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=">
<script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/tsumli.github.io\/"},"articleSection":"blog","name":"Taskonomyを読む","headline":"Taskonomyを読む","description":"","inLanguage":"en-US","author":"","creator":"","publisher":"","accountablePerson":"","copyrightHolder":"","copyrightYear":"2021","datePublished":"2021-02-01 13:55:54 \u002b0000 UTC","dateModified":"2021-02-01 13:55:54 \u002b0000 UTC","url":"https:\/\/tsumli.github.io\/blog\/paper\/taskonomy\/","wordCount":"1430","keywords":["転移学習","Taskonomy","transfer-learning","Blog"]}</script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-188554402-1','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
</head>
<body>
<div class=burger__container>
<div class=burger aria-controls=navigation aria-label=Menu>
<div class="burger__meat burger__meat--1"></div>
<div class="burger__meat burger__meat--2"></div>
<div class="burger__meat burger__meat--3"></div>
</div>
</div>
<nav class=nav id=navigation>
<ul class=nav__list>
<li>
<a href=https://tsumli.github.io/>about</a>
</li>
<li>
<a class=active href=https://tsumli.github.io/blog>blog</a>
</li>
</ul>
</nav>
<main>
<div class=flex-wrapper>
<div class=post__container>
<div class=post>
<header class=post__header>
<h1 id=post__title>Taskonomyを読む</h1>
<time datetime="2021-02-01 13:55:54 +0000 UTC" class=post__date>Feb 1 2021</time>
<link rel=stylesheet href=https://tsumli.github.io//css/lightbox.min.css>
<script type=text/javascript>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],processEscapes:!0,tags:"ams",autoload:{color:[],colorV2:['color']},packages:{'[+]':['noerrors']}},chtml:{matchFontHeight:!1,displayAlign:"left",displayIndent:"2em"},options:{skipHtmlTags:['script','noscript','style','textarea','pre'],renderActions:{find_script_mathtex:[10,function(a){for(const b of document.querySelectorAll('script[type^="math/tex"]')){const e=!!b.type.match(/; *mode=display/),c=new a.options.MathItem(b.textContent,a.inputJax[0],e),d=document.createTextNode('');b.parentNode.replaceChild(d,b),c.start={node:d,delim:'',n:0},c.end={node:d,delim:'',n:0},a.math.push(c)}},'']}},loader:{load:['[tex]/noerrors']}}</script>
<script type=text/javascript async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js id=MathJax-script></script>
<link rel=stylesheet type=text/css href=https://tsumli.github.io/css/mathjax-style.css>
</header>
<article class=post__content>
<p><a href=https://arxiv.org/abs/1804.08328 target=_blank rel="noreferrer noopener"><strong>Taskonomy: Disentangling Task Transfer Learning</strong></a>
という論文を読んでいきます。
この論文はCVPR 2018のBestPaperを受賞しています (本文中の図は論文より引用) 。</p>
<h2 id=motivation>Motivation<a class=anchor href=#motivation>#</a></h2>
<p>タスク間の転移学習しやすさが分かれば、アノテーションの足りないデータを扱う、または性能を向上させたいときにどのタスクで事前学習を行うべきかが分かる。</p>
<h2 id=method>Method<a class=anchor href=#method>#</a></h2>
<p>手法は「sourceタスク$\rightarrow$targetタスクで転移学習し、誤差を比較する」という流れです。<br>
用意したsourceタスクの集合を$\mathcal{S}$、targetタスクの集合を$\mathcal{T}$とします。
今回は$|\mathcal{S}| = 26, |\mathcal{T}|=22$となっています (source-onlyタスクが4種類) 。</p>
<h3 id=1-task-specific-modeling>1. <strong>Task-Specific Modeling</strong><a class=anchor href=#1-task-specific-modeling>#</a></h3>
<p>Sourceタスクそれぞれで教師あり学習を行います。
ネットワークはエンコーダとデコーダを持ちます。エンコーダの構造は同一 (ResNet50を修正したもの) ですが、<strong>デコーダの構造はタスクによって異なります</strong>。</p>
<h3 id=2-transfer-modeling>2. <strong>Transfer Modeling</strong><a class=anchor href=#2-transfer-modeling>#</a></h3>
<p>$s\in \mathcal{S}$ と $t\in \mathcal{T}$ が与えられたとき、$s\rightarrow t$ と転移学習を行ったときの$t$でのパフォーマンスを求めます。
このとき、エンコーダは $s$ で学習したもので固定し、$t$ でデコーダのみ学習させます。</p>
<h3 id=3-analytic-hierarchy-process-ahp-による正規化>3. <strong>Analytic Hierarchy Process (AHP) による正規化</strong><a class=anchor href=#3-analytic-hierarchy-process-ahp-による正規化>#</a></h3>
<p>転移学習しやすさのAffinity Matrix (相性の行列) を計算します。
直感的には、「 $s\rightarrow t$ に転移学習したときの最終的な$t$でのテスト誤差をそのまま $[0, 1]$ にスケールさせて用いる」という方法が考えられますが、そうすると
テスト誤差に対しての本当のクオリティが変わるスピードが異なる場合に問題となります (例えば、Segmentationでの誤差が1/2になるのと、edge検出での誤差が 1/2 になるのは同じだけ性能が向上したとは言えません) 。
つまり、何かしらの方法を用いて<strong>正規化</strong>しなければいけません。
そこでAHP法 (固有値を用いる方法 <a href=https://core.ac.uk/download/pdf/96975029.pdf target=_blank rel="noreferrer noopener">参考</a>
) を用います。
AHP法を用いると、ある$t\in\mathcal{T}$に対してどの$s\in\mathcal{S}$が重要 (効率的) なのかが分かります。つまり、ある$t$に対して、$i$番目が$s_i$の重要性を表すようなベクトル$\mathbf{s}\in \mathbb{R}^{|\mathcal{S}|}$が得られるということです。
すべての$\mathcal{T}$について重要性を計算したあと、$(i, j)$要素が$t_i$に対する$s_j$の重要性を表すようにベクトルを結合していくと、Affinity Matrixを求めることができます (下図右) 。 ここで、下図左の行列は正規化を行わなかったときのAffinity Matrixを表しており、正規化することで違いが理解しやすくなっていることが分かります。
<figure style="margin:0 auto;text-align:center">
<a data-lightbox=image-images/normalize.png href=https://tsumli.github.io/blog/paper/taskonomy/images/normalize.png>
<img src=https://tsumli.github.io/blog/paper/taskonomy/images/normalize.png>
</a>
</figure>
</p>
<h3 id=4-computing-the-grobal-taxonomy>4. <strong>Computing the Grobal Taxonomy</strong><a class=anchor href=#4-computing-the-grobal-taxonomy>#</a></h3>
<p>さて、Affinity Matrixが与えられたとき、$t\in \mathcal{T}$のパフォーマンスを最大化する$\mathcal{S}$の部分集合を考えます。
これは、与えられた予算の中で目標を最大化させるという問題に帰着し、整数計画法 (Boolean Integer Programming; BIP) を用いて解くことができます。</p>
<h2 id=result>Result<a class=anchor href=#result>#</a></h2>
<p>おそらく論文より<a href=http://taskonomy.stanford.edu/ target=_blank rel="noreferrer noopener">プロジェクトサイト</a>
のAPIを見たほうが早いです。
$\mathcal{S}, \mathcal{T}$、そして予算などを指定してあげると、どのタスクがどのタスクに効率的に転移学習が行えるかが表示されます。</p>
<h2 id=memo>Memo<a class=anchor href=#memo>#</a></h2>
<p>約48000時間GPUで計算したというこの論文。圧倒的な資金力。</p>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
<script type=text/x-mathjax-config>
    MathJax.Hub.Config({
            showMathMenu: false, //disables context menu
            tex2jax: {
            inlineMath: [ ['$','$'], ['\\(','\\)'] ]
           }
    });
</script>
</article>
<ul class=tags__list>
<li class=tag__item>
<a class=tag__link href=https://tsumli.github.io/tags/transfer-learning/>transfer-learning</a>
</li>
<li class=tag__item>
<a class=tag__link href=https://tsumli.github.io/tags/paper/>paper</a>
</li></ul>
<div class=pagination>
<a class=pagination__item href=https://tsumli.github.io/blog/abci/singularity/>
<span class=pagination__label>Next Post</span>
<span class=pagination__title>自分的Singularityの使い方</span>
</a>
</div>
<footer class=post__footer>
<div class=social-icons>
<a class=social-icons__link rel=me title=Kaggle href=https://www.kaggle.com/tsumli target=_blank rel=noopener>
<div class=social-icons__icon style=background-image:url(https://tsumli.github.io/svg/kaggle.svg)></div>
</a>
<a class=social-icons__link rel=me title=GitHub href=https://github.com/tsumli target=_blank rel=noopener>
<div class=social-icons__icon style=background-image:url(https://tsumli.github.io/svg/github.svg)></div>
</a>
<a class=social-icons__link rel=me title=Medium href=https://medium.com/@tsumli target=_blank rel=noopener>
<div class=social-icons__icon style=background-image:url(https://tsumli.github.io/svg/medium.svg)></div>
</a>
</div>
<p>© 2023</p>
<script src=https://code.jquery.com/jquery-3.4.1.min.js integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin=anonymous></script>
<link rel=stylesheet href=https://tsumli.github.io//css/lightbox.min.css>
<script src=https://tsumli.github.io//js/lightbox.min.js></script>
</footer>
</div>
</div>
<div class=toc-container>
<div class=toc-post-title>Taskonomyを読む</div>
<nav id=TableOfContents>
<ul>
<li><a href=#motivation>Motivation</a></li>
<li><a href=#method>Method</a>
<ul>
<li><a href=#1-task-specific-modeling>1. <strong>Task-Specific Modeling</strong></a></li>
<li><a href=#2-transfer-modeling>2. <strong>Transfer Modeling</strong></a></li>
<li><a href=#3-analytic-hierarchy-process-ahp-による正規化>3. <strong>Analytic Hierarchy Process (AHP) による正規化</strong></a></li>
<li><a href=#4-computing-the-grobal-taxonomy>4. <strong>Computing the Grobal Taxonomy</strong></a></li>
</ul>
</li>
<li><a href=#result>Result</a></li>
<li><a href=#memo>Memo</a></li>
</ul>
</nav>
</div>
</div>
</main>
<script src=https://tsumli.github.io/js/index.min.575dda8d49ee02639942c63564273e6da972ab531dda26a08800bdcb477cbd7f.js integrity="sha256-V13ajUnuAmOZQsY1ZCc+balyq1Md2iagiAC9y0d8vX8=" crossorigin=anonymous></script>
<script src=https://unpkg.com/prismjs@1.20.0/components/prism-core.min.js></script>
<script src=https://unpkg.com/prismjs@1.20.0/plugins/autoloader/prism-autoloader.min.js data-autoloader-path=https://unpkg.com/prismjs@1.20.0/components/></script>
<script src=https://tsumli.github.io/js/table-of-contents.js></script>
</body>
</html>