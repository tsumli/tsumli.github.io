<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>transfer-learning on tsumli-pages</title>
    <link>https://tsumli.github.io/tags/transfer-learning/</link>
    <description>Recent content in transfer-learning on tsumli-pages</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© {year}</copyright>
    <lastBuildDate>Mon, 01 Feb 2021 13:55:54 +0000</lastBuildDate><atom:link href="https://tsumli.github.io/tags/transfer-learning/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Taskonomyを読む</title>
      <link>https://tsumli.github.io/blog/paper/taskonomy/</link>
      <pubDate>Mon, 01 Feb 2021 13:55:54 +0000</pubDate>
      
      <guid>https://tsumli.github.io/blog/paper/taskonomy/</guid>
      <description>Taskonomy: Disentangling Task Transfer Learning という論文を読んでいきます。 この論文はCVPR 2018のBestPaperを受賞しています (本文中の図は論文より引用) 。
Motivation タスク間の転移学習しやすさが分かれば、アノテーションの足りないデータを扱う、または性能を向上させたいときにどのタスクで事前学習を行うべきかが分かる。
Method 手法は「sourceタスク$\rightarrow$targetタスクで転移学習し、誤差を比較する」という流れです。
用意したsourceタスクの集合を$\mathcal{S}$、targetタスクの集合を$\mathcal{T}$とします。 今回は$|\mathcal{S}| = 26, |\mathcal{T}|=22$となっています (source-onlyタスクが4種類) 。
  Task-Specific Modeling
Sourceタスクそれぞれで教師あり学習を行います。 ネットワークはエンコーダとデコーダを持ちます。エンコーダの構造は同一 (ResNet50を修正したもの) ですが、デコーダの構造はタスクによって異なります。
  Transfer Modeling
$s\in \mathcal{S}$ と $t\in \mathcal{T}$ が与えられたとき、$s\rightarrow t$と転移学習を行ったときの$t$でのパフォーマンスを求めたいとします。 このとき、エンコーダは$s$で学習したもので固定し、$t$でデコーダのみ学習させます。
  Analytic Hierarchy Process (AHP) による正規化
転移学習しやすさのAffinity Matrix (相性の行列) を計算します。 直感的には、「$s\rightarrow t$に転移学習したときの最終的な$t$でのテスト誤差をそのまま$[0, 1]$にスケールさせて用いる」という方法が考えられますが、そうすると テスト誤差に対しての本当のクオリティが変わるスピードが異なる場合に問題となります (例えば、Segmentationでの誤差が1/2になるのと、edge検出での誤差が1/2になるのは同じだけ性能が向上したとは言えません) 。 つまり、何かしらの方法を用いて正規化しなければいけません。 そこでAHP法 (固有値を用いる方法 参考 ) を用います。 AHP法を用いると、ある$t\in\mathcal{T}$に対してどの$s\in\mathcal{S}$が重要 (効率的) なのかが分かります。つまり、ある$t$に対して、$i$番目が$s_i$の重要性を表すようなベクトル$\mathbf{s}\in \mathbb{R}^{|\mathcal{S}|}$が得られるということです。 すべての$\mathcal{T}$について重要性を計算したあと、$(i, j)$要素が$t_i$に対する$s_j$の重要性を表すようにベクトルを結合していくと、Affinity Matrixを求めることができます (下図右) 。 ここで、下図左の行列は正規化を行わなかったときのAfinity Matrixを表しており、正規化することで違いが理解しやすくなっていることが分かります。     Computing the Grobal Taxonomy</description>
    </item>
    
  </channel>
</rss>
